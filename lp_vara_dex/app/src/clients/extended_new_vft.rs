// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct WvaraVftFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> WvaraVftFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::WvaraVftFactory for WvaraVftFactory<R> {
    type Args = R::Args;
    fn new(&self, name: String, symbol: String, decimals: u8) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, wvara_vft_factory::io::New>::new(
            self.remoting.clone(),
            (name, symbol, decimals),
        )
    }
}
pub mod wvara_vft_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(name: String, symbol: String, decimals: u8) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(name, symbol, decimals))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (String, String, u8);
            type Reply = ();
        }
    }
}
pub struct Vft<R> {
    remoting: R,
}
impl<R> Vft<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Vft for Vft<R> {
    type Args = R::Args;
    fn deposit(&mut self) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Deposit>::new(self.remoting.clone(), ())
    }
    fn withdraw(&mut self, value: U256) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Withdraw>::new(self.remoting.clone(), value)
    }
    fn approve(
        &mut self,
        spender: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Approve>::new(self.remoting.clone(), (spender, value))
    }
    fn transfer(&mut self, to: ActorId, value: U256) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Transfer>::new(self.remoting.clone(), (to, value))
    }
    fn transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::TransferFrom>::new(self.remoting.clone(), (from, to, value))
    }
    fn allowance(
        &self,
        owner: ActorId,
        spender: ActorId,
    ) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::Allowance>::new(self.remoting.clone(), (owner, spender))
    }
    fn balance_of(&self, account: ActorId) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::BalanceOf>::new(self.remoting.clone(), account)
    }
    fn decimals(&self) -> impl Query<Output = u8, Args = R::Args> {
        RemotingAction::<_, vft::io::Decimals>::new(self.remoting.clone(), ())
    }
    fn name(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vft::io::Name>::new(self.remoting.clone(), ())
    }
    fn symbol(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vft::io::Symbol>::new(self.remoting.clone(), ())
    }
    fn total_supply(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::TotalSupply>::new(self.remoting.clone(), ())
    }
}
pub mod vft {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Deposit(());
        impl Deposit {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Deposit as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Deposit {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 28, 68, 101, 112, 111, 115, 105, 116];
            type Params = ();
            type Reply = bool;
        }
        pub struct Withdraw(());
        impl Withdraw {
            #[allow(dead_code)]
            pub fn encode_call(value: U256) -> Vec<u8> {
                <Withdraw as ActionIo>::encode_call(&value)
            }
        }
        impl ActionIo for Withdraw {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 32, 87, 105, 116, 104, 100, 114, 97, 119];
            type Params = U256;
            type Reply = bool;
        }
        pub struct Approve(());
        impl Approve {
            #[allow(dead_code)]
            pub fn encode_call(spender: ActorId, value: U256) -> Vec<u8> {
                <Approve as ActionIo>::encode_call(&(spender, value))
            }
        }
        impl ActionIo for Approve {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 28, 65, 112, 112, 114, 111, 118, 101];
            type Params = (ActorId, U256);
            type Reply = bool;
        }
        pub struct Transfer(());
        impl Transfer {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, value: U256) -> Vec<u8> {
                <Transfer as ActionIo>::encode_call(&(to, value))
            }
        }
        impl ActionIo for Transfer {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 32, 84, 114, 97, 110, 115, 102, 101, 114];
            type Params = (ActorId, U256);
            type Reply = bool;
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId, value: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(from, to, value))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 48, 84, 114, 97, 110, 115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = bool;
        }
        pub struct Allowance(());
        impl Allowance {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, spender: ActorId) -> Vec<u8> {
                <Allowance as ActionIo>::encode_call(&(owner, spender))
            }
        }
        impl ActionIo for Allowance {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 36, 65, 108, 108, 111, 119, 97, 110, 99, 101,
            ];
            type Params = (ActorId, ActorId);
            type Reply = U256;
        }
        pub struct BalanceOf(());
        impl BalanceOf {
            #[allow(dead_code)]
            pub fn encode_call(account: ActorId) -> Vec<u8> {
                <BalanceOf as ActionIo>::encode_call(&account)
            }
        }
        impl ActionIo for BalanceOf {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 36, 66, 97, 108, 97, 110, 99, 101, 79, 102];
            type Params = ActorId;
            type Reply = U256;
        }
        pub struct Decimals(());
        impl Decimals {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Decimals as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Decimals {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 32, 68, 101, 99, 105, 109, 97, 108, 115];
            type Params = ();
            type Reply = u8;
        }
        pub struct Name(());
        impl Name {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Name as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Name {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 16, 78, 97, 109, 101];
            type Params = ();
            type Reply = String;
        }
        pub struct Symbol(());
        impl Symbol {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Symbol as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Symbol {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 24, 83, 121, 109, 98, 111, 108];
            type Params = ();
            type Reply = String;
        }
        pub struct TotalSupply(());
        impl TotalSupply {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TotalSupply as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TotalSupply {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 44, 84, 111, 116, 97, 108, 83, 117, 112, 112, 108, 121,
            ];
            type Params = ();
            type Reply = U256;
        }
    }
    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftEvents {
            Deposit {
                dst: ActorId,
                wad: U256,
            },
            Withdraw {
                src: ActorId,
                wad: U256,
            },
            Approval {
                owner: ActorId,
                spender: ActorId,
                value: U256,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                value: U256,
            },
        }
        impl EventIo for VftEvents {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[28, 68, 101, 112, 111, 115, 105, 116],
                &[32, 87, 105, 116, 104, 100, 114, 97, 119],
                &[32, 65, 112, 112, 114, 111, 118, 97, 108],
                &[32, 84, 114, 97, 110, 115, 102, 101, 114],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<VftEvents> {
            RemotingListener::<_, VftEvents>::new(remoting)
        }
    }
}
pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait WvaraVftFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(
            &self,
            name: String,
            symbol: String,
            decimals: u8,
        ) -> impl Activation<Args = Self::Args>;
    }
    #[allow(clippy::type_complexity)]
    pub trait Vft {
        type Args;
        fn deposit(&mut self) -> impl Call<Output = bool, Args = Self::Args>;
        fn withdraw(&mut self, value: U256) -> impl Call<Output = bool, Args = Self::Args>;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn balance_of(&self, account: ActorId) -> impl Query<Output = U256, Args = Self::Args>;
        fn decimals(&self) -> impl Query<Output = u8, Args = Self::Args>;
        fn name(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn symbol(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn total_supply(&self) -> impl Query<Output = U256, Args = Self::Args>;
    }
}
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub Vft<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::Vft for Vft<A> { type Args = A; fn deposit (&mut self, ) -> MockCall<A, bool>;fn withdraw (&mut self, value: U256,) -> MockCall<A, bool>;fn approve (&mut self, spender: ActorId,value: U256,) -> MockCall<A, bool>;fn transfer (&mut self, to: ActorId,value: U256,) -> MockCall<A, bool>;fn transfer_from (&mut self, from: ActorId,to: ActorId,value: U256,) -> MockCall<A, bool>;fn allowance (& self, owner: ActorId,spender: ActorId,) -> MockQuery<A, U256>;fn balance_of (& self, account: ActorId,) -> MockQuery<A, U256>;fn decimals (& self, ) -> MockQuery<A, u8>;fn name (& self, ) -> MockQuery<A, String>;fn symbol (& self, ) -> MockQuery<A, String>;fn total_supply (& self, ) -> MockQuery<A, U256>; } }
}
