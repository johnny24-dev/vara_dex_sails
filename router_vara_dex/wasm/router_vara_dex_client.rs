// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct RouterVaraDexFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> RouterVaraDexFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::RouterVaraDexFactory for RouterVaraDexFactory<R> {
    type Args = R::Args;
    fn new(&self, factory: ActorId, wvara: ActorId) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, router_vara_dex_factory::io::New>::new(
            self.remoting.clone(),
            (factory, wvara),
        )
    }
}
pub mod router_vara_dex_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(factory: ActorId, wvara: ActorId) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(factory, wvara))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (ActorId, ActorId);
            type Reply = ();
        }
    }
}
pub struct RouterService<R> {
    remoting: R,
}
impl<R> RouterService<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::RouterService for RouterService<R> {
    type Args = R::Args;
    fn add_liquidity(
        &mut self,
        token_a: ActorId,
        token_b: ActorId,
        amount_a_desired: U256,
        amount_b_desired: U256,
        amount_a_min: U256,
        amount_b_min: U256,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<(U256, U256, U256), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::AddLiquidity>::new(
            self.remoting.clone(),
            (
                token_a,
                token_b,
                amount_a_desired,
                amount_b_desired,
                amount_a_min,
                amount_b_min,
                to,
                deadline,
            ),
        )
    }
    fn add_liquidity_vara(
        &mut self,
        token: ActorId,
        amount_token_desired: U256,
        amount_token_min: U256,
        amount_vara_min: U256,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<(U256, U256, U256), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::AddLiquidityVara>::new(
            self.remoting.clone(),
            (
                token,
                amount_token_desired,
                amount_token_min,
                amount_vara_min,
                to,
                deadline,
            ),
        )
    }
    fn create_pair(
        &mut self,
        token_a: ActorId,
        token_b: ActorId,
    ) -> impl Call<Output = Result<(), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::CreatePair>::new(
            self.remoting.clone(),
            (token_a, token_b),
        )
    }
    fn remove_liquidity(
        &mut self,
        token_a: ActorId,
        token_b: ActorId,
        liquidity: U256,
        amount_a_min: U256,
        amount_b_min: U256,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<(U256, U256), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::RemoveLiquidity>::new(
            self.remoting.clone(),
            (
                token_a,
                token_b,
                liquidity,
                amount_a_min,
                amount_b_min,
                to,
                deadline,
            ),
        )
    }
    fn remove_liquidity_vara(
        &mut self,
        token: ActorId,
        liquidity: U256,
        amount_token_min: U256,
        amount_vara_min: U256,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<(U256, U256), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::RemoveLiquidityVara>::new(
            self.remoting.clone(),
            (
                token,
                liquidity,
                amount_token_min,
                amount_vara_min,
                to,
                deadline,
            ),
        )
    }
    fn swap_exact_tokens_for_tokens(
        &mut self,
        amount_in: U256,
        amount_out_min: U256,
        path: Vec<ActorId>,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SwapExactTokensForTokens>::new(
            self.remoting.clone(),
            (amount_in, amount_out_min, path, to, deadline),
        )
    }
    fn swap_exact_tokens_for_vara(
        &mut self,
        amount_in: U256,
        amount_out_min: U256,
        path: Vec<ActorId>,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SwapExactTokensForVara>::new(
            self.remoting.clone(),
            (amount_in, amount_out_min, path, to, deadline),
        )
    }
    fn swap_exact_vara_for_tokens(
        &mut self,
        amount_out_min: U256,
        path: Vec<ActorId>,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SwapExactVaraForTokens>::new(
            self.remoting.clone(),
            (amount_out_min, path, to, deadline),
        )
    }
    fn swap_tokens_for_exact_tokens(
        &mut self,
        amount_out: U256,
        amount_in_max: U256,
        path: Vec<ActorId>,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SwapTokensForExactTokens>::new(
            self.remoting.clone(),
            (amount_out, amount_in_max, path, to, deadline),
        )
    }
    fn swap_tokens_for_exact_vara(
        &mut self,
        amount_out: U256,
        amount_in_max: U256,
        path: Vec<ActorId>,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SwapTokensForExactVara>::new(
            self.remoting.clone(),
            (amount_out, amount_in_max, path, to, deadline),
        )
    }
    fn swap_vara_for_exact_tokens(
        &mut self,
        amount_out: U256,
        path: Vec<ActorId>,
        to: ActorId,
        deadline: u64,
    ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SwapVaraForExactTokens>::new(
            self.remoting.clone(),
            (amount_out, path, to, deadline),
        )
    }
    fn transfer_from_liquidity(
        &mut self,
        pair: ActorId,
        from: ActorId,
        to: ActorId,
        liquidity: U256,
    ) -> impl Call<Output = Result<(), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::TransferFromLiquidity>::new(
            self.remoting.clone(),
            (pair, from, to, liquidity),
        )
    }
    fn transfer_liquidity(
        &mut self,
        pair: ActorId,
        to: ActorId,
        liquidity: U256,
    ) -> impl Call<Output = Result<(), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::TransferLiquidity>::new(
            self.remoting.clone(),
            (pair, to, liquidity),
        )
    }
    fn get_amount_in(
        &self,
        amount_out: U256,
        reserve_in: U256,
        reserve_out: U256,
    ) -> impl Query<Output = Result<U256, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::GetAmountIn>::new(
            self.remoting.clone(),
            (amount_out, reserve_in, reserve_out),
        )
    }
    fn get_amount_out(
        &self,
        amount_in: U256,
        reserve_in: U256,
        reserve_out: U256,
    ) -> impl Query<Output = Result<U256, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::GetAmountOut>::new(
            self.remoting.clone(),
            (amount_in, reserve_in, reserve_out),
        )
    }
    fn get_amounts_in(
        &self,
        amount_out: U256,
        path: Vec<ActorId>,
    ) -> impl Query<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::GetAmountsIn>::new(
            self.remoting.clone(),
            (amount_out, path),
        )
    }
    fn get_amounts_out(
        &self,
        amount_in: U256,
        path: Vec<ActorId>,
    ) -> impl Query<Output = Result<Vec<U256>, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::GetAmountsOut>::new(
            self.remoting.clone(),
            (amount_in, path),
        )
    }
    fn get_reserves(
        &self,
        token_a: ActorId,
        token_b: ActorId,
    ) -> impl Query<Output = Result<(U256, U256, ActorId), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::GetReserves>::new(
            self.remoting.clone(),
            (token_a, token_b),
        )
    }
    fn pair_for(
        &self,
        token_a: ActorId,
        token_b: ActorId,
    ) -> impl Query<Output = Result<ActorId, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::PairFor>::new(
            self.remoting.clone(),
            (token_a, token_b),
        )
    }
    fn quote(
        &self,
        amount_a: U256,
        reserve_a: U256,
        reserve_b: U256,
    ) -> impl Query<Output = Result<U256, RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::Quote>::new(
            self.remoting.clone(),
            (amount_a, reserve_a, reserve_b),
        )
    }
    fn sort_tokens(
        &self,
        token_a: ActorId,
        token_b: ActorId,
    ) -> impl Query<Output = Result<(ActorId, ActorId), RouterError>, Args = R::Args> {
        RemotingAction::<_, router_service::io::SortTokens>::new(
            self.remoting.clone(),
            (token_a, token_b),
        )
    }
}
pub mod router_service {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddLiquidity(());
        impl AddLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(
                token_a: ActorId,
                token_b: ActorId,
                amount_a_desired: U256,
                amount_b_desired: U256,
                amount_a_min: U256,
                amount_b_min: U256,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <AddLiquidity as ActionIo>::encode_call(&(
                    token_a,
                    token_b,
                    amount_a_desired,
                    amount_b_desired,
                    amount_a_min,
                    amount_b_min,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for AddLiquidity {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 48, 65, 100, 100,
                76, 105, 113, 117, 105, 100, 105, 116, 121,
            ];
            type Params = (ActorId, ActorId, U256, U256, U256, U256, ActorId, u64);
            type Reply = Result<(U256, U256, U256), super::RouterError>;
        }
        pub struct AddLiquidityVara(());
        impl AddLiquidityVara {
            #[allow(dead_code)]
            pub fn encode_call(
                token: ActorId,
                amount_token_desired: U256,
                amount_token_min: U256,
                amount_vara_min: U256,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <AddLiquidityVara as ActionIo>::encode_call(&(
                    token,
                    amount_token_desired,
                    amount_token_min,
                    amount_vara_min,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for AddLiquidityVara {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 64, 65, 100, 100,
                76, 105, 113, 117, 105, 100, 105, 116, 121, 86, 97, 114, 97,
            ];
            type Params = (ActorId, U256, U256, U256, ActorId, u64);
            type Reply = Result<(U256, U256, U256), super::RouterError>;
        }
        pub struct CreatePair(());
        impl CreatePair {
            #[allow(dead_code)]
            pub fn encode_call(token_a: ActorId, token_b: ActorId) -> Vec<u8> {
                <CreatePair as ActionIo>::encode_call(&(token_a, token_b))
            }
        }
        impl ActionIo for CreatePair {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 40, 67, 114, 101,
                97, 116, 101, 80, 97, 105, 114,
            ];
            type Params = (ActorId, ActorId);
            type Reply = Result<(), super::RouterError>;
        }
        pub struct RemoveLiquidity(());
        impl RemoveLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(
                token_a: ActorId,
                token_b: ActorId,
                liquidity: U256,
                amount_a_min: U256,
                amount_b_min: U256,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <RemoveLiquidity as ActionIo>::encode_call(&(
                    token_a,
                    token_b,
                    liquidity,
                    amount_a_min,
                    amount_b_min,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for RemoveLiquidity {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 60, 82, 101, 109,
                111, 118, 101, 76, 105, 113, 117, 105, 100, 105, 116, 121,
            ];
            type Params = (ActorId, ActorId, U256, U256, U256, ActorId, u64);
            type Reply = Result<(U256, U256), super::RouterError>;
        }
        pub struct RemoveLiquidityVara(());
        impl RemoveLiquidityVara {
            #[allow(dead_code)]
            pub fn encode_call(
                token: ActorId,
                liquidity: U256,
                amount_token_min: U256,
                amount_vara_min: U256,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <RemoveLiquidityVara as ActionIo>::encode_call(&(
                    token,
                    liquidity,
                    amount_token_min,
                    amount_vara_min,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for RemoveLiquidityVara {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 76, 82, 101, 109,
                111, 118, 101, 76, 105, 113, 117, 105, 100, 105, 116, 121, 86, 97, 114, 97,
            ];
            type Params = (ActorId, U256, U256, U256, ActorId, u64);
            type Reply = Result<(U256, U256), super::RouterError>;
        }
        pub struct SwapExactTokensForTokens(());
        impl SwapExactTokensForTokens {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_in: U256,
                amount_out_min: U256,
                path: Vec<ActorId>,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapExactTokensForTokens as ActionIo>::encode_call(&(
                    amount_in,
                    amount_out_min,
                    path,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapExactTokensForTokens {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 96, 83, 119, 97,
                112, 69, 120, 97, 99, 116, 84, 111, 107, 101, 110, 115, 70, 111, 114, 84, 111, 107,
                101, 110, 115,
            ];
            type Params = (U256, U256, Vec<ActorId>, ActorId, u64);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct SwapExactTokensForVara(());
        impl SwapExactTokensForVara {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_in: U256,
                amount_out_min: U256,
                path: Vec<ActorId>,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapExactTokensForVara as ActionIo>::encode_call(&(
                    amount_in,
                    amount_out_min,
                    path,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapExactTokensForVara {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 88, 83, 119, 97,
                112, 69, 120, 97, 99, 116, 84, 111, 107, 101, 110, 115, 70, 111, 114, 86, 97, 114,
                97,
            ];
            type Params = (U256, U256, Vec<ActorId>, ActorId, u64);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct SwapExactVaraForTokens(());
        impl SwapExactVaraForTokens {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_out_min: U256,
                path: Vec<ActorId>,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapExactVaraForTokens as ActionIo>::encode_call(&(
                    amount_out_min,
                    path,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapExactVaraForTokens {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 88, 83, 119, 97,
                112, 69, 120, 97, 99, 116, 86, 97, 114, 97, 70, 111, 114, 84, 111, 107, 101, 110,
                115,
            ];
            type Params = (U256, Vec<ActorId>, ActorId, u64);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct SwapTokensForExactTokens(());
        impl SwapTokensForExactTokens {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_out: U256,
                amount_in_max: U256,
                path: Vec<ActorId>,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapTokensForExactTokens as ActionIo>::encode_call(&(
                    amount_out,
                    amount_in_max,
                    path,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapTokensForExactTokens {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 96, 83, 119, 97,
                112, 84, 111, 107, 101, 110, 115, 70, 111, 114, 69, 120, 97, 99, 116, 84, 111, 107,
                101, 110, 115,
            ];
            type Params = (U256, U256, Vec<ActorId>, ActorId, u64);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct SwapTokensForExactVara(());
        impl SwapTokensForExactVara {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_out: U256,
                amount_in_max: U256,
                path: Vec<ActorId>,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapTokensForExactVara as ActionIo>::encode_call(&(
                    amount_out,
                    amount_in_max,
                    path,
                    to,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapTokensForExactVara {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 88, 83, 119, 97,
                112, 84, 111, 107, 101, 110, 115, 70, 111, 114, 69, 120, 97, 99, 116, 86, 97, 114,
                97,
            ];
            type Params = (U256, U256, Vec<ActorId>, ActorId, u64);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct SwapVaraForExactTokens(());
        impl SwapVaraForExactTokens {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_out: U256,
                path: Vec<ActorId>,
                to: ActorId,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapVaraForExactTokens as ActionIo>::encode_call(&(amount_out, path, to, deadline))
            }
        }
        impl ActionIo for SwapVaraForExactTokens {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 88, 83, 119, 97,
                112, 86, 97, 114, 97, 70, 111, 114, 69, 120, 97, 99, 116, 84, 111, 107, 101, 110,
                115,
            ];
            type Params = (U256, Vec<ActorId>, ActorId, u64);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct TransferFromLiquidity(());
        impl TransferFromLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(
                pair: ActorId,
                from: ActorId,
                to: ActorId,
                liquidity: U256,
            ) -> Vec<u8> {
                <TransferFromLiquidity as ActionIo>::encode_call(&(pair, from, to, liquidity))
            }
        }
        impl ActionIo for TransferFromLiquidity {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 84, 84, 114, 97,
                110, 115, 102, 101, 114, 70, 114, 111, 109, 76, 105, 113, 117, 105, 100, 105, 116,
                121,
            ];
            type Params = (ActorId, ActorId, ActorId, U256);
            type Reply = Result<(), super::RouterError>;
        }
        pub struct TransferLiquidity(());
        impl TransferLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(pair: ActorId, to: ActorId, liquidity: U256) -> Vec<u8> {
                <TransferLiquidity as ActionIo>::encode_call(&(pair, to, liquidity))
            }
        }
        impl ActionIo for TransferLiquidity {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 68, 84, 114, 97,
                110, 115, 102, 101, 114, 76, 105, 113, 117, 105, 100, 105, 116, 121,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = Result<(), super::RouterError>;
        }
        pub struct GetAmountIn(());
        impl GetAmountIn {
            #[allow(dead_code)]
            pub fn encode_call(amount_out: U256, reserve_in: U256, reserve_out: U256) -> Vec<u8> {
                <GetAmountIn as ActionIo>::encode_call(&(amount_out, reserve_in, reserve_out))
            }
        }
        impl ActionIo for GetAmountIn {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 44, 71, 101, 116,
                65, 109, 111, 117, 110, 116, 73, 110,
            ];
            type Params = (U256, U256, U256);
            type Reply = Result<U256, super::RouterError>;
        }
        pub struct GetAmountOut(());
        impl GetAmountOut {
            #[allow(dead_code)]
            pub fn encode_call(amount_in: U256, reserve_in: U256, reserve_out: U256) -> Vec<u8> {
                <GetAmountOut as ActionIo>::encode_call(&(amount_in, reserve_in, reserve_out))
            }
        }
        impl ActionIo for GetAmountOut {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 48, 71, 101, 116,
                65, 109, 111, 117, 110, 116, 79, 117, 116,
            ];
            type Params = (U256, U256, U256);
            type Reply = Result<U256, super::RouterError>;
        }
        pub struct GetAmountsIn(());
        impl GetAmountsIn {
            #[allow(dead_code)]
            pub fn encode_call(amount_out: U256, path: Vec<ActorId>) -> Vec<u8> {
                <GetAmountsIn as ActionIo>::encode_call(&(amount_out, path))
            }
        }
        impl ActionIo for GetAmountsIn {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 48, 71, 101, 116,
                65, 109, 111, 117, 110, 116, 115, 73, 110,
            ];
            type Params = (U256, Vec<ActorId>);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct GetAmountsOut(());
        impl GetAmountsOut {
            #[allow(dead_code)]
            pub fn encode_call(amount_in: U256, path: Vec<ActorId>) -> Vec<u8> {
                <GetAmountsOut as ActionIo>::encode_call(&(amount_in, path))
            }
        }
        impl ActionIo for GetAmountsOut {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 52, 71, 101, 116,
                65, 109, 111, 117, 110, 116, 115, 79, 117, 116,
            ];
            type Params = (U256, Vec<ActorId>);
            type Reply = Result<Vec<U256>, super::RouterError>;
        }
        pub struct GetReserves(());
        impl GetReserves {
            #[allow(dead_code)]
            pub fn encode_call(token_a: ActorId, token_b: ActorId) -> Vec<u8> {
                <GetReserves as ActionIo>::encode_call(&(token_a, token_b))
            }
        }
        impl ActionIo for GetReserves {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 44, 71, 101, 116,
                82, 101, 115, 101, 114, 118, 101, 115,
            ];
            type Params = (ActorId, ActorId);
            type Reply = Result<(U256, U256, ActorId), super::RouterError>;
        }
        pub struct PairFor(());
        impl PairFor {
            #[allow(dead_code)]
            pub fn encode_call(token_a: ActorId, token_b: ActorId) -> Vec<u8> {
                <PairFor as ActionIo>::encode_call(&(token_a, token_b))
            }
        }
        impl ActionIo for PairFor {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 28, 80, 97, 105,
                114, 70, 111, 114,
            ];
            type Params = (ActorId, ActorId);
            type Reply = Result<ActorId, super::RouterError>;
        }
        pub struct Quote(());
        impl Quote {
            #[allow(dead_code)]
            pub fn encode_call(amount_a: U256, reserve_a: U256, reserve_b: U256) -> Vec<u8> {
                <Quote as ActionIo>::encode_call(&(amount_a, reserve_a, reserve_b))
            }
        }
        impl ActionIo for Quote {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 20, 81, 117, 111,
                116, 101,
            ];
            type Params = (U256, U256, U256);
            type Reply = Result<U256, super::RouterError>;
        }
        pub struct SortTokens(());
        impl SortTokens {
            #[allow(dead_code)]
            pub fn encode_call(token_a: ActorId, token_b: ActorId) -> Vec<u8> {
                <SortTokens as ActionIo>::encode_call(&(token_a, token_b))
            }
        }
        impl ActionIo for SortTokens {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101, 40, 83, 111, 114,
                116, 84, 111, 107, 101, 110, 115,
            ];
            type Params = (ActorId, ActorId);
            type Reply = Result<(ActorId, ActorId), super::RouterError>;
        }
    }
    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum RouterServiceEvents {
            CreatePair {
                token_a: ActorId,
                token_b: ActorId,
                pair_address: ActorId,
            },
            AddLiquidity {
                token_a: ActorId,
                token_b: ActorId,
                amount_a: U256,
                amount_b: U256,
                to: ActorId,
                liquidity: U256,
            },
            AddLiquidityVARA {
                token_a: ActorId,
                amount_a: U256,
                amount_vara: U256,
                to: ActorId,
                liquidity: U256,
            },
            RemoveLiquidity {
                token_a: ActorId,
                token_b: ActorId,
                amount_a_received: U256,
                amount_b_received: U256,
                to: ActorId,
                liquidity: U256,
            },
            RemoveLiquidityVARA {
                token_a: ActorId,
                amount_a_received: U256,
                amount_vara_received: U256,
                to: ActorId,
                liquidity: U256,
            },
            SwapExactTokensForTokens {
                amount_in: U256,
                amount_out: U256,
                path: Vec<ActorId>,
                to: ActorId,
            },
            SwapTokensForExactTokens {
                amount_out: U256,
                amount_in: U256,
                path: Vec<ActorId>,
                to: ActorId,
            },
            SwapExactVARAForTokens {
                amount_in: U256,
                amount_out: U256,
                path: Vec<ActorId>,
                to: ActorId,
            },
            SwapTokensForExactVARA {
                amount_out: U256,
                amount_in: U256,
                path: Vec<ActorId>,
                to: ActorId,
            },
            SwapExactTokensForVARA {
                amount_in: U256,
                amount_out: U256,
                path: Vec<ActorId>,
                to: ActorId,
            },
            SwapVARAForExactTokens {
                amount_out: U256,
                amount_in: U256,
                path: Vec<ActorId>,
                to: ActorId,
            },
        }
        impl EventIo for RouterServiceEvents {
            const ROUTE: &'static [u8] = &[
                52, 82, 111, 117, 116, 101, 114, 83, 101, 114, 118, 105, 99, 101,
            ];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[40, 67, 114, 101, 97, 116, 101, 80, 97, 105, 114],
                &[48, 65, 100, 100, 76, 105, 113, 117, 105, 100, 105, 116, 121],
                &[
                    64, 65, 100, 100, 76, 105, 113, 117, 105, 100, 105, 116, 121, 86, 65, 82, 65,
                ],
                &[
                    60, 82, 101, 109, 111, 118, 101, 76, 105, 113, 117, 105, 100, 105, 116, 121,
                ],
                &[
                    76, 82, 101, 109, 111, 118, 101, 76, 105, 113, 117, 105, 100, 105, 116, 121,
                    86, 65, 82, 65,
                ],
                &[
                    96, 83, 119, 97, 112, 69, 120, 97, 99, 116, 84, 111, 107, 101, 110, 115, 70,
                    111, 114, 84, 111, 107, 101, 110, 115,
                ],
                &[
                    96, 83, 119, 97, 112, 84, 111, 107, 101, 110, 115, 70, 111, 114, 69, 120, 97,
                    99, 116, 84, 111, 107, 101, 110, 115,
                ],
                &[
                    88, 83, 119, 97, 112, 69, 120, 97, 99, 116, 86, 65, 82, 65, 70, 111, 114, 84,
                    111, 107, 101, 110, 115,
                ],
                &[
                    88, 83, 119, 97, 112, 84, 111, 107, 101, 110, 115, 70, 111, 114, 69, 120, 97,
                    99, 116, 86, 65, 82, 65,
                ],
                &[
                    88, 83, 119, 97, 112, 69, 120, 97, 99, 116, 84, 111, 107, 101, 110, 115, 70,
                    111, 114, 86, 65, 82, 65,
                ],
                &[
                    88, 83, 119, 97, 112, 86, 65, 82, 65, 70, 111, 114, 69, 120, 97, 99, 116, 84,
                    111, 107, 101, 110, 115,
                ],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<RouterServiceEvents> {
            RemotingListener::<_, RouterServiceEvents>::new(remoting)
        }
    }
}
#[derive(PartialEq, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum RouterError {
    PairAlreadyExists,
    TransferLiquidityFailed,
    TransferFromLiquidityFailed,
    TransferFromFailed,
    InsufficientFee,
    BurnLiquidityFailed,
    InsufficientVaraAmount,
    InsufficientTokenAmount,
    CreatePairFailed,
    WithdrawWvaraFailed,
    DepositWVARAFailed,
    SwapFailed,
    MintLiquidityFailed,
    Expired,
    PairNotFound,
    IdenticalAddresses,
    ZeroAddress,
    InsufficientBAmount,
    InsufficientAAmount,
    InsufficientLiquidity,
    InvalidPath,
    InsufficientOutputAmount,
    InsufficientInputAmount,
    InvalidLiquidityAmount,
    ExcessiveInputAmount,
    TransferFailed,
}
pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait RouterVaraDexFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self, factory: ActorId, wvara: ActorId) -> impl Activation<Args = Self::Args>;
    }
    #[allow(clippy::type_complexity)]
    pub trait RouterService {
        type Args;
        fn add_liquidity(
            &mut self,
            token_a: ActorId,
            token_b: ActorId,
            amount_a_desired: U256,
            amount_b_desired: U256,
            amount_a_min: U256,
            amount_b_min: U256,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<(U256, U256, U256), RouterError>, Args = Self::Args>;
        fn add_liquidity_vara(
            &mut self,
            token: ActorId,
            amount_token_desired: U256,
            amount_token_min: U256,
            amount_vara_min: U256,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<(U256, U256, U256), RouterError>, Args = Self::Args>;
        fn create_pair(
            &mut self,
            token_a: ActorId,
            token_b: ActorId,
        ) -> impl Call<Output = Result<(), RouterError>, Args = Self::Args>;
        fn remove_liquidity(
            &mut self,
            token_a: ActorId,
            token_b: ActorId,
            liquidity: U256,
            amount_a_min: U256,
            amount_b_min: U256,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<(U256, U256), RouterError>, Args = Self::Args>;
        fn remove_liquidity_vara(
            &mut self,
            token: ActorId,
            liquidity: U256,
            amount_token_min: U256,
            amount_vara_min: U256,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<(U256, U256), RouterError>, Args = Self::Args>;
        fn swap_exact_tokens_for_tokens(
            &mut self,
            amount_in: U256,
            amount_out_min: U256,
            path: Vec<ActorId>,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn swap_exact_tokens_for_vara(
            &mut self,
            amount_in: U256,
            amount_out_min: U256,
            path: Vec<ActorId>,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn swap_exact_vara_for_tokens(
            &mut self,
            amount_out_min: U256,
            path: Vec<ActorId>,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn swap_tokens_for_exact_tokens(
            &mut self,
            amount_out: U256,
            amount_in_max: U256,
            path: Vec<ActorId>,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn swap_tokens_for_exact_vara(
            &mut self,
            amount_out: U256,
            amount_in_max: U256,
            path: Vec<ActorId>,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn swap_vara_for_exact_tokens(
            &mut self,
            amount_out: U256,
            path: Vec<ActorId>,
            to: ActorId,
            deadline: u64,
        ) -> impl Call<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn transfer_from_liquidity(
            &mut self,
            pair: ActorId,
            from: ActorId,
            to: ActorId,
            liquidity: U256,
        ) -> impl Call<Output = Result<(), RouterError>, Args = Self::Args>;
        fn transfer_liquidity(
            &mut self,
            pair: ActorId,
            to: ActorId,
            liquidity: U256,
        ) -> impl Call<Output = Result<(), RouterError>, Args = Self::Args>;
        fn get_amount_in(
            &self,
            amount_out: U256,
            reserve_in: U256,
            reserve_out: U256,
        ) -> impl Query<Output = Result<U256, RouterError>, Args = Self::Args>;
        fn get_amount_out(
            &self,
            amount_in: U256,
            reserve_in: U256,
            reserve_out: U256,
        ) -> impl Query<Output = Result<U256, RouterError>, Args = Self::Args>;
        fn get_amounts_in(
            &self,
            amount_out: U256,
            path: Vec<ActorId>,
        ) -> impl Query<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn get_amounts_out(
            &self,
            amount_in: U256,
            path: Vec<ActorId>,
        ) -> impl Query<Output = Result<Vec<U256>, RouterError>, Args = Self::Args>;
        fn get_reserves(
            &self,
            token_a: ActorId,
            token_b: ActorId,
        ) -> impl Query<Output = Result<(U256, U256, ActorId), RouterError>, Args = Self::Args>;
        fn pair_for(
            &self,
            token_a: ActorId,
            token_b: ActorId,
        ) -> impl Query<Output = Result<ActorId, RouterError>, Args = Self::Args>;
        fn quote(
            &self,
            amount_a: U256,
            reserve_a: U256,
            reserve_b: U256,
        ) -> impl Query<Output = Result<U256, RouterError>, Args = Self::Args>;
        fn sort_tokens(
            &self,
            token_a: ActorId,
            token_b: ActorId,
        ) -> impl Query<Output = Result<(ActorId, ActorId), RouterError>, Args = Self::Args>;
    }
}
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub RouterService<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::RouterService for RouterService<A> { type Args = A; fn add_liquidity (&mut self, token_a: ActorId,token_b: ActorId,amount_a_desired: U256,amount_b_desired: U256,amount_a_min: U256,amount_b_min: U256,to: ActorId,deadline: u64,) -> MockCall<A, Result<(U256,U256,U256,), RouterError>>;fn add_liquidity_vara (&mut self, token: ActorId,amount_token_desired: U256,amount_token_min: U256,amount_vara_min: U256,to: ActorId,deadline: u64,) -> MockCall<A, Result<(U256,U256,U256,), RouterError>>;fn create_pair (&mut self, token_a: ActorId,token_b: ActorId,) -> MockCall<A, Result<(), RouterError>>;fn remove_liquidity (&mut self, token_a: ActorId,token_b: ActorId,liquidity: U256,amount_a_min: U256,amount_b_min: U256,to: ActorId,deadline: u64,) -> MockCall<A, Result<(U256,U256,), RouterError>>;fn remove_liquidity_vara (&mut self, token: ActorId,liquidity: U256,amount_token_min: U256,amount_vara_min: U256,to: ActorId,deadline: u64,) -> MockCall<A, Result<(U256,U256,), RouterError>>;fn swap_exact_tokens_for_tokens (&mut self, amount_in: U256,amount_out_min: U256,path: Vec<ActorId>,to: ActorId,deadline: u64,) -> MockCall<A, Result<Vec<U256>, RouterError>>;fn swap_exact_tokens_for_vara (&mut self, amount_in: U256,amount_out_min: U256,path: Vec<ActorId>,to: ActorId,deadline: u64,) -> MockCall<A, Result<Vec<U256>, RouterError>>;fn swap_exact_vara_for_tokens (&mut self, amount_out_min: U256,path: Vec<ActorId>,to: ActorId,deadline: u64,) -> MockCall<A, Result<Vec<U256>, RouterError>>;fn swap_tokens_for_exact_tokens (&mut self, amount_out: U256,amount_in_max: U256,path: Vec<ActorId>,to: ActorId,deadline: u64,) -> MockCall<A, Result<Vec<U256>, RouterError>>;fn swap_tokens_for_exact_vara (&mut self, amount_out: U256,amount_in_max: U256,path: Vec<ActorId>,to: ActorId,deadline: u64,) -> MockCall<A, Result<Vec<U256>, RouterError>>;fn swap_vara_for_exact_tokens (&mut self, amount_out: U256,path: Vec<ActorId>,to: ActorId,deadline: u64,) -> MockCall<A, Result<Vec<U256>, RouterError>>;fn transfer_from_liquidity (&mut self, pair: ActorId,from: ActorId,to: ActorId,liquidity: U256,) -> MockCall<A, Result<(), RouterError>>;fn transfer_liquidity (&mut self, pair: ActorId,to: ActorId,liquidity: U256,) -> MockCall<A, Result<(), RouterError>>;fn get_amount_in (& self, amount_out: U256,reserve_in: U256,reserve_out: U256,) -> MockQuery<A, Result<U256, RouterError>>;fn get_amount_out (& self, amount_in: U256,reserve_in: U256,reserve_out: U256,) -> MockQuery<A, Result<U256, RouterError>>;fn get_amounts_in (& self, amount_out: U256,path: Vec<ActorId>,) -> MockQuery<A, Result<Vec<U256>, RouterError>>;fn get_amounts_out (& self, amount_in: U256,path: Vec<ActorId>,) -> MockQuery<A, Result<Vec<U256>, RouterError>>;fn get_reserves (& self, token_a: ActorId,token_b: ActorId,) -> MockQuery<A, Result<(U256,U256,ActorId,), RouterError>>;fn pair_for (& self, token_a: ActorId,token_b: ActorId,) -> MockQuery<A, Result<ActorId, RouterError>>;fn quote (& self, amount_a: U256,reserve_a: U256,reserve_b: U256,) -> MockQuery<A, Result<U256, RouterError>>;fn sort_tokens (& self, token_a: ActorId,token_b: ActorId,) -> MockQuery<A, Result<(ActorId,ActorId,), RouterError>>; } }
}
