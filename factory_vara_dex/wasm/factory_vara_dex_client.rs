// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct FactoryVaraDexFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> FactoryVaraDexFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::FactoryVaraDexFactory for FactoryVaraDexFactory<R> {
    type Args = R::Args;
    fn new(
        &self,
        code_id_pair: CodeId,
        fee_to: ActorId,
        fee_to_setter: ActorId,
    ) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, factory_vara_dex_factory::io::New>::new(
            self.remoting.clone(),
            (code_id_pair, fee_to, fee_to_setter),
        )
    }
}
pub mod factory_vara_dex_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(
                code_id_pair: CodeId,
                fee_to: ActorId,
                fee_to_setter: ActorId,
            ) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(code_id_pair, fee_to, fee_to_setter))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (CodeId, ActorId, ActorId);
            type Reply = ();
        }
    }
}
pub struct FactoryService<R> {
    remoting: R,
}
impl<R> FactoryService<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::FactoryService for FactoryService<R> {
    type Args = R::Args;
    fn create_pair(
        &mut self,
        token_a: ActorId,
        token_b: ActorId,
    ) -> impl Call<Output = Result<ActorId, FactoryError>, Args = R::Args> {
        RemotingAction::<_, factory_service::io::CreatePair>::new(
            self.remoting.clone(),
            (token_a, token_b),
        )
    }
    fn set_fee_to(
        &mut self,
        new_fee_to: ActorId,
    ) -> impl Call<Output = Result<(), FactoryError>, Args = R::Args> {
        RemotingAction::<_, factory_service::io::SetFeeTo>::new(self.remoting.clone(), new_fee_to)
    }
    fn set_fee_to_setter(
        &mut self,
        new_fee_setter: ActorId,
    ) -> impl Call<Output = Result<(), FactoryError>, Args = R::Args> {
        RemotingAction::<_, factory_service::io::SetFeeToSetter>::new(
            self.remoting.clone(),
            new_fee_setter,
        )
    }
    fn get_fee_to(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, factory_service::io::GetFeeTo>::new(self.remoting.clone(), ())
    }
    fn get_fee_to_setter(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, factory_service::io::GetFeeToSetter>::new(self.remoting.clone(), ())
    }
    fn get_pair(
        &self,
        token_a: ActorId,
        token_b: ActorId,
    ) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, factory_service::io::GetPair>::new(
            self.remoting.clone(),
            (token_a, token_b),
        )
    }
    fn get_pair_length(&self) -> impl Query<Output = u64, Args = R::Args> {
        RemotingAction::<_, factory_service::io::GetPairLength>::new(self.remoting.clone(), ())
    }
}
pub mod factory_service {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct CreatePair(());
        impl CreatePair {
            #[allow(dead_code)]
            pub fn encode_call(token_a: ActorId, token_b: ActorId) -> Vec<u8> {
                <CreatePair as ActionIo>::encode_call(&(token_a, token_b))
            }
        }
        impl ActionIo for CreatePair {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 40, 67, 114,
                101, 97, 116, 101, 80, 97, 105, 114,
            ];
            type Params = (ActorId, ActorId);
            type Reply = Result<ActorId, super::FactoryError>;
        }
        pub struct SetFeeTo(());
        impl SetFeeTo {
            #[allow(dead_code)]
            pub fn encode_call(new_fee_to: ActorId) -> Vec<u8> {
                <SetFeeTo as ActionIo>::encode_call(&new_fee_to)
            }
        }
        impl ActionIo for SetFeeTo {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 32, 83, 101,
                116, 70, 101, 101, 84, 111,
            ];
            type Params = ActorId;
            type Reply = Result<(), super::FactoryError>;
        }
        pub struct SetFeeToSetter(());
        impl SetFeeToSetter {
            #[allow(dead_code)]
            pub fn encode_call(new_fee_setter: ActorId) -> Vec<u8> {
                <SetFeeToSetter as ActionIo>::encode_call(&new_fee_setter)
            }
        }
        impl ActionIo for SetFeeToSetter {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 56, 83, 101,
                116, 70, 101, 101, 84, 111, 83, 101, 116, 116, 101, 114,
            ];
            type Params = ActorId;
            type Reply = Result<(), super::FactoryError>;
        }
        pub struct GetFeeTo(());
        impl GetFeeTo {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetFeeTo as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetFeeTo {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 32, 71, 101,
                116, 70, 101, 101, 84, 111,
            ];
            type Params = ();
            type Reply = ActorId;
        }
        pub struct GetFeeToSetter(());
        impl GetFeeToSetter {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetFeeToSetter as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetFeeToSetter {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 56, 71, 101,
                116, 70, 101, 101, 84, 111, 83, 101, 116, 116, 101, 114,
            ];
            type Params = ();
            type Reply = ActorId;
        }
        pub struct GetPair(());
        impl GetPair {
            #[allow(dead_code)]
            pub fn encode_call(token_a: ActorId, token_b: ActorId) -> Vec<u8> {
                <GetPair as ActionIo>::encode_call(&(token_a, token_b))
            }
        }
        impl ActionIo for GetPair {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 28, 71, 101,
                116, 80, 97, 105, 114,
            ];
            type Params = (ActorId, ActorId);
            type Reply = ActorId;
        }
        pub struct GetPairLength(());
        impl GetPairLength {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetPairLength as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetPairLength {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101, 52, 71, 101,
                116, 80, 97, 105, 114, 76, 101, 110, 103, 116, 104,
            ];
            type Params = ();
            type Reply = u64;
        }
    }
    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum FactoryServiceEvents {
            PairCreated {
                token_pair: (ActorId, ActorId),
                pair_address: ActorId,
                pair_number: u64,
            },
            FeeToSetterSet(ActorId),
            FeeToSet(ActorId),
            Pair(ActorId),
        }
        impl EventIo for FactoryServiceEvents {
            const ROUTE: &'static [u8] = &[
                56, 70, 97, 99, 116, 111, 114, 121, 83, 101, 114, 118, 105, 99, 101,
            ];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[44, 80, 97, 105, 114, 67, 114, 101, 97, 116, 101, 100],
                &[
                    56, 70, 101, 101, 84, 111, 83, 101, 116, 116, 101, 114, 83, 101, 116,
                ],
                &[32, 70, 101, 101, 84, 111, 83, 101, 116],
                &[16, 80, 97, 105, 114],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<FactoryServiceEvents> {
            RemotingListener::<_, FactoryServiceEvents>::new(remoting)
        }
    }
}
#[derive(PartialEq, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum FactoryError {
    Unauthorized,
    UnexpectedFTEvent,
    MessageSendError,
    NotFound,
    PairExist,
    PairCreationFailed,
    PairNotExist,
    VFTError,
}
pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait FactoryVaraDexFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(
            &self,
            code_id_pair: CodeId,
            fee_to: ActorId,
            fee_to_setter: ActorId,
        ) -> impl Activation<Args = Self::Args>;
    }
    #[allow(clippy::type_complexity)]
    pub trait FactoryService {
        type Args;
        fn create_pair(
            &mut self,
            token_a: ActorId,
            token_b: ActorId,
        ) -> impl Call<Output = Result<ActorId, FactoryError>, Args = Self::Args>;
        fn set_fee_to(
            &mut self,
            new_fee_to: ActorId,
        ) -> impl Call<Output = Result<(), FactoryError>, Args = Self::Args>;
        fn set_fee_to_setter(
            &mut self,
            new_fee_setter: ActorId,
        ) -> impl Call<Output = Result<(), FactoryError>, Args = Self::Args>;
        fn get_fee_to(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn get_fee_to_setter(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn get_pair(
            &self,
            token_a: ActorId,
            token_b: ActorId,
        ) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn get_pair_length(&self) -> impl Query<Output = u64, Args = Self::Args>;
    }
}
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub FactoryService<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::FactoryService for FactoryService<A> { type Args = A; fn create_pair (&mut self, token_a: ActorId,token_b: ActorId,) -> MockCall<A, Result<ActorId, FactoryError>>;fn set_fee_to (&mut self, new_fee_to: ActorId,) -> MockCall<A, Result<(), FactoryError>>;fn set_fee_to_setter (&mut self, new_fee_setter: ActorId,) -> MockCall<A, Result<(), FactoryError>>;fn get_fee_to (& self, ) -> MockQuery<A, ActorId>;fn get_fee_to_setter (& self, ) -> MockQuery<A, ActorId>;fn get_pair (& self, token_a: ActorId,token_b: ActorId,) -> MockQuery<A, ActorId>;fn get_pair_length (& self, ) -> MockQuery<A, u64>; } }
}
